---
강의 리스트:
  - "[[컴퓨터 알고리즘]]"
생성 일시: 2022-09-19
유형: 필기
주차:
  - 3주차
  - 4주차
  - 5주차
---
- [[#정렬]]
    - [[#정렬 알고리즘의 종류]]
    - [[#간단한 정렬 알고리즘]]
    - [[#효율적인 정렬 알고리즘]]

# 정렬

- 데이터를 순서대로 재배열하는 것
- 비교할 수 있는 모든 속성들은 정렬의 기준이 될 수 있다

  

## 정렬 알고리즘의 종류

- 정렬 장소에 따라
    - 내부 정렬 : 데이터를 메인 메모리에
    - 외부 정렬 : 데이터를 외부 기억 장치에
- 단순하지만 비효율적인 방법
    - 삽입, 선택, 버블 정렬
- 복잡하지만 효율적인 방법
    - 퀵, 힙, 병합, 기수 정렬

> [!important] **정렬 알고리즘의 안정성**
> 
>   
> : 같은 값의 데이터를 정렬 했을 때 초기의 순서가 유지 되어야 함  

  

  

## 간단한 정렬 알고리즘

### 선택 정렬 (Selection Sort)

![[/Untitled 49.png|Untitled 49.png]]

- 오른쪽 리스트의 가장 작은 숫자를 선택하여 왼쪽 리스트의 맨 뒤로 이동하는 작업 반복
- 시간복잡도
    
    $$(n-1)+(n-2)+･･･+1=\frac{n(n-1)}{2} =O(n^2)$$
    
- 선택 정렬의 특징
    - 입력에 민감하지 않음  
        → 항상 $O(N^2)$ 수행시간 소요
    - 최솟값을 찾은 후 원소를 교환하는 횟수가 N-1회  
        → 정렬 알고리즘 중 가장 작은 최악의 경우 교환 횟수  
        
    - 하지만 효율성 측면에서 뒤떨어져 거의 활용되지 않음

---

  

### 삽입 정렬 (Insertion Sort)

![[/Untitled 1 21.png|Untitled 1 21.png]]

- 리스트를 정렬된 부분과 안된 부분으로 나누고, 안된 부분의 가장 왼쪽 원소(i)를 바로 앞의 원소(i-1)과 비교하며 정렬된 부분에 삽입하는 방식의 정렬 알고리즘

**수행시간**

- 작은 데이터들이 뒤에 몰려있을 경우 비효율적임 → 입력에 민감하다
- 입력이 이미 정렬된 경우 (최선) → N-1번 비교로 정렬을 마침 = $O(N)$
- 입력이 역으로 정렬된 경우 (최악) → $\frac{1}{2}N^2$번 비교 = $O(N^2)$
- 입력이 랜덤인 경우 (평균) = $O(N^2)$

  

**응용**

- 이미 정렬된 파일의 뒷부분에 소량의 데이터 추가시 우수한 성능
- 입력 크기가 작은 경우에도 우수한 성능
- 합병정렬, 퀵정렬과 함께 사용시 빠른 성능에 도움을 줌

  

**특징**

- 많은 이동 필요 → 레코드가 큰 경우 불리
- 대부분 정렬되어 있을때 효율적

---

  

### 버블 정렬 (Bubble Sort)

![[/Untitled 2 17.png|Untitled 2 17.png]]

- 인접한 2개의 레코드를 비교하여 순서대로 서로 교환
- 비교-교환 과정을 리스트 전체에서 수행  
    → 리스트 가장 오른쪽에 가장 큰 레코드가 위치  
    
- 정렬 중간에 교체가 안일어났다면 정렬이 끝났다고 판단하고 정렬 과정을 멈춤

  

**버블정렬 분석**

- 비교 횟수 (최상, 최악, 평균 모두 동일)

$$\frac {n(n-1)}{2} = O(n^2)$$

- 이동 횟수
    - 역순의 경우(최악) : 이동 횟수 = 3 x 비교 횟수
    - 정렬된 경우(최선) : 이동횟수 = 0
    - 평균의 경우 : $O(n^2)$가

---

  

### **간단한 정렬 알고리즘의 특징**

- 선택 정렬 : 입력의 크기에 따라 자료 이동 횟수가 결정
- 삽입 정렬 : 레코드의 많은 이동이 필요, 이미 정렬되어 있는 경우 효율적
- 버블 정렬 : 가장 간단한 알고리즘

  

  

## 효율적인 정렬 알고리즘

### 쉘 정렬

- 삽입 정렬에 전처리 과정이 추가된 것
- 전처리 과정
    - 작은 값을 가진 원소들을 배열 앞으로 옮기며 큰값이 뒤에 자리잡도록 만드는 과정
    - 여러 단계로 진행되며, 각 단계에서는 일정 간격으로 떨어진 원소들에 대해 삽입 정렬 수행
- 과정
    - 리스트를 일정 간격의 부분 리스트로 나눔
        - 최초의 간격은 N//2+1
        - 첫번째와 5칸 뒤의 원소가 묶여 부분 리스트 됨
    - 각 리스트를 삽입 정렬 실시
    - 간격을 줄여가면서 반복
    - 간격이 1이 되면 삽입 정렬과 동일하게 됨

  

**쉘 정렬 분석**

- 장점
    - 부분 리스트에서 원거리 자료 이동으로 보다 적은 위치 교환으로 제자리 찾을 가능성 증가
    - 점진적으로 정렬된 상태가 되므로 삽입 정렬 속도 증가
    - 입력이 크지 않을때 효율적
- 시간 복잡도
    - 최악 : $O(n^2)$
    - 평균 : $O(n^{1.5})$

---

  

### 힙 정렬 분석

- 이진힙을 이용한 정렬
- 추가적인 메모리를 필요로 함

  

**과정**

- 배열속 데이터의 키를 우선순위로 하는 최대힙을 구성
- 루트와 힙의 마지막 노드를 교환하고 힙크기 1 감소
    - 힙트리의 마지막이된 루트노드를 제외하는 과정
- 위배된 힙속성을 다운힙 연산으로 복원
    - N/2번 노드부터 루트 노드까지 다운힙 연산 실시
    - 자식노드끼리 비교하여 큰 노드를 부모 노드와 비교하여 교환
    - 배열로 볼때 부모 노드의 인덱스가 n일때 그 자식의 인덱스는 2n과 2n+1이 된다

  

> [!important] **이진힙**
> 
> 자식노드를 최대 2개까지 가질수 있는 **완전이진트리** 기반으로 부모-자식 노드간의 **우선순위**가 정해진 자료구조 → 최대힙, 최소힙 중 하나로 정해져있어야 이진힙 만족
> 
> - 완전이진트리 : 자식노드가 왼쪽부터 차곡차곡 들어찬 자료구조  
>     → 1차원 리스트로 구현하며 인덱스 0번은 사용하지 않음  
>     
>     포화이진트리 : 말단노드를 제외하고 모든 노드가 자식노드를 2개씩 갖는 자료구조
>     
> - 반정렬 : 부모-자식 간에는 우선순위가 있지만 형제끼리는 우선순위가 없어 완전정렬 아님
> - downheap : 루트와 승자인 자식을 비교하여 힙속성이 만족될 때까지 말단노드 방향으로 진행
> - upheap : 단말에서 루트로 나아가면서 부모와 비교하여 힙속성 만족할 때까지 교환

> [!important] **힙트리의 규칙**
> 
> - 전체 노드 수 : $2^n -1$ (n = 힙트리의 총 레벨 수)
> - 인덱스 번호 N/2+1부터 N까지는 모두 말단 노드  
>     → 따라서 상향식 힙을 만들때는 N/2 부터 1번 까지를 다운힙 연산 하면 됨  
>     

---

  

### 병합 정렬

- 분할 정복 방법
    - 리스트를 2개의 균등한 부분리스트로 분할

  

병합 정렬 복잡도 분석

- 시간복잡도
    - 비교 횟수
        - 크기 n인 리스트 균등 분배 → $log(n)$개의 패스(분할작업)
        - 각 패스에서 레코드 n개를 비교 → n번의 비교연산
    - 이동 횟수
        - 각 패스에서 2n번 이동 발생 → 전체 이동 : $2n*log(n)$
    - 시간 복잡도 = $O(n*log(n))$
- 분석
    - 효율적인 알고리즘
    - 최적, 평균, 최악의 경우 모두 동일한 시간에 정렬
    - 추가적인 메모리 필요

---

  

  

### 퀵 정렬

- 분할 정복 방법
    - 리스트를 2개의 비균등한 부분리스트로 분할
    - 피벗 값(보통 배열의 맨 왼쪽)을 선택하여 이를 중심으로 왼쪽은 작은 요소, 오른쪽은 큰 요소로 분할

  

**퀵 정렬 복잡도 분석**

- 최선의 경우
    - 균등분할
    - 패스 수 : $log(n)$
    - 복잡도 : $O(n*log(n))$
- 최악의 경우
    - 이미 정렬된 리스트
    - 패스 수 : $n$
    - 복잡도 : $O(n^2)$
- 특징
    - 평균적으로 빠른 수행 시간, 보조 메모리 사용하지 않음

  

**성능 향상 방법**

1. 입력이 작아졌을 때 삽입 정렬 사용
2. 피벗값을 랜덤한 3개의 원소의 중간값으로 사용 (Median-of-Three 방법)
3. 9개의 원소를 3개씩 묶어 각 그룹의 중간값들의 중간값을 피벗으로 사용
4. 퀵 정렬 전에 랜덤 섞기를 수행

---

  

### 기수 정렬

- 키를 부분적으로 비교하는 정렬
    - 키가 숫자라면, 각 자릿수에 대해 키를 비교
- LSD 기수 정렬 : 자릿수 비교를 최하위 숫자부터 최상위 숫자 방향으로 정렬
- MSD 기수 정렬 : 반대

  

**세자리수 십진수 키 LSD 기수 정렬**

1. 각 키의 1의 자리만을 비교하여 작은 수 부터 큰 수로 정렬
2. 10의 자리 정렬
3. 100의 자리 정렬

- 이전 정렬에서의 위치 순서를 유지하면서 정렬 (안정성 유지)

  

**한자리수 키의 기수 정렬**

- 고정된 숫자 테이블인 버킷에 입력 원소들을 배분하고 위에서부터 차례대로 출력
- 두자릿수 키의 경우 본 과정을 자릿수에 따라 한번 더 실행

  

**기수 정렬 분석**

- 버킷의 개수는 키의 표현 방법과 관련됨
    - 이진법 → 버킷 2개
    - 알파벳 → 버킷 26개
- n개의 레코드, d개의 자릿수 키의 기수 정렬
    - 메인 루프는 자릿수 d만큼 반복
    - 큐에 n개의 입력 수행
- 시간 복잡도 : O(dn), 대부분 d ≤ 10
- 특정 숫자와 문자에 대하여 좋은 성능을 보임 → 인터넷 주소, 주민등록번호 정렬시 효율적
- 선형크기의 추가 메모리 필요
- 입력 크기가 커질수록 캐시메모리 비효율적 사용
- 루프내에 명령어가 많음